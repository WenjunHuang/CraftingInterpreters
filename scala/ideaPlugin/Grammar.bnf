{
psiPackage = "com.github.wenjunhuang.lox.ideaplugin.psi"
psiImplPackage = "com.github.wenjunhuang.lox.ideaplugin.psi.impl"
parserClass = "com.github.wenjunhuang.lox.ideaplugin.LoxParser"
implements = "com.github.wenjunhuang.lox.ideaplugin.psi.LoxPsiCompositeElement"
parserUtilClass="com.github.wenjunhuang.lox.ideaplugin.LoxParserUtil"
elementTypeHolderClass = "com.github.wenjunhuang.lox.ideaplugin.LoxTypes"
elementTypeClass = "com.github.wenjunhuang.lox.ideaplugin.LoxElementType"
tokenTypeClass="com.github.wenjunhuang.lox.ideaplugin.LoxTokenType"

tokens=[
FUN = 'fun'
IF = 'if'
ELSE = 'else'
FOR = 'for'
WHILE = 'while'
SEMICOLON = ';'
EQUAL = '='
EQUAL_EQUAL = '=='
LEFT_PAREN = '('
RIGHT_PAREN = ')'
LEFT_BRACE = '{'
RIGHT_BRACE = '}'
COMMA = ','
DOT = '.'
MINUS = '-'
PLUS = '+'
SLASH = '/'
STAR = '*'
BANG = '!'
BANG_EQUAL = '!='
GREATER = '>'
GREATER_EQUAL = '>='
LESS = '<'
LESS_EQUAL = '<='
AND = 'and'
OR = 'or'
CLASS = 'class'
TRUE = 'true'
FALSE = 'false'
NIL = 'nil'
PRINT = 'print'
RETURN = 'return'
SUPER = 'super'
INIT = 'init'
THIS = 'this'
VAR = 'var'
CLASS = 'class'

LINE_COMMENT='regexp://.*'
BLOCK_COMMENT = 'regexp:/\*(.|\n)*\*/'
NUMBER='regexp:\d+(\.\d*)?'
IDENTIFIER='regexp:\p{Alpha}\w*'
STRING="regexp:('([^'\\]\\.)*'|\"([^\"\\]|\\.)*\")"
SPACE="regexp:\s+"
]

extends(".*Expr") = expression
extends(".*Stmt") = statement
}
program ::= declaration *
declaration ::= varDecl | classDecl |  funDecl | statement {recoverWhile=declarationRecover}
private declarationRecover ::= !('class' | 'fun' | 'var' |'if' | 'print' | '{'|'}' )

classDecl ::= "class" IDENTIFIER ("<" IDENTIFIER)? classBody {pin = 2}
classBody ::="{" (classInitializer | classMethod)* "}"
{methods=[getInitializers getMethods]}

classInitializer ::= "init" "(" parameters? ")" blockStmt {pin=1}
classMethod ::= IDENTIFIER "(" parameters? ")" blockStmt {pin=1}

funDecl ::= 'fun' IDENTIFIER "(" parameters? ")" blockStmt  {pin=2}
parameters ::= IDENTIFIER ("," IDENTIFIER)*

varDecl ::= "var" IDENTIFIER ("=" expression )? ";" {pin=2 }

statement ::= printStmt | blockStmt | ifStmt | whileStmt |forStmt|returnStmt| exprStmt
returnStmt ::= "return" expression? ";"
whileStmt ::= "while" "(" expression ")" statement
printStmt ::= "print" expression ";" {pin=1}
blockStmt ::= '{' declaration* '}'
ifStmt ::= 'if' '(' expression ")" statement ("else" statement)?
exprStmt ::= expression ";"
forStmt ::= "for" "(" (varDecl | exprStmt |";") expression? ";" expression? ")" statement

expression ::= assignmentExprWrapper
private assignmentExprWrapper ::= (callExprWrapper ".")? IDENTIFIER '=' assignmentExpr | logicOrExprWrapper
private logicOrExprWrapper ::= logicAndExprWrapper logicOrExpr*
 left logicOrExpr ::= 'or' logicAndExprWrapper
private logicAndExprWrapper ::= equalityExprWrapper logicAndExprWrapper*
 left logicAndExpr ::= 'and' equalityExpr
equalityExpr ::= comparisonExpr (('!=' | '==') comparisonExpr)*
comparisonExpr ::= termExpr (('>'|'>='|'<'|'<=') termExpr)*
termExpr ::= factorExpr (( '-'|'+') factorExpr)*
factorExpr ::= unaryExpr (('/'|'*') unaryExpr)*
unaryExpr ::= ('!'|'-') unaryExpr | callExpr
callExpr ::= primaryExpr ("(" arguments? ")" | "." IDENTIFIER)*
arguments ::= expression ("," expression)*
primaryExpr ::= NUMBER | STRING | 'this' | 'true' | 'false' | 'nil' | IDENTIFIER | '(' expression ')'
